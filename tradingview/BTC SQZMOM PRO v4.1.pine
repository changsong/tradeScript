//@version=6
strategy(
     "BTC SQZMOM PRO v4.1 SAFE",
     overlay=false,
     initial_capital=100000,
     pyramiding=0,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=100,
     commission_type=strategy.commission.percent,
     commission_value=0.04,
     calc_on_every_tick=false,
     process_orders_on_close=true)

//==================================================
// 参数
//==================================================
bbLen  = input.int(20)
bbMult = input.float(2.0)
kcLen  = input.int(20)
kcMult = input.float(1.5)
useTR  = input.bool(true)

htfTF  = input.timeframe("60")
emaLen = input.int(200)
atrLen = input.int(14)

baseRR = input.float(1.8)
maxRR  = input.float(3.0)

maxLossStreak = input.int(3)

//==================================================
// 时段过滤（UTC）
//==================================================
h = hour(time)
sessionOK = (h >= 0 and h <= 8) or (h >= 13 and h <= 20)

//==================================================
// SQZMOM 函数（稳定版）
//==================================================
f_sqzmom(_src) =>
    basis = ta.sma(_src, bbLen)
    dev   = bbMult * ta.stdev(_src, bbLen)
    upperBB = basis + dev
    lowerBB = basis - dev

    ma = ta.sma(_src, kcLen)
    rng = useTR ? ta.tr(true) : high - low
    rangema = ta.sma(rng, kcLen)
    upperKC = ma + rangema * kcMult
    lowerKC = ma - rangema * kcMult

    sqzOn  = lowerBB > lowerKC and upperBB < upperKC
    sqzOff = lowerBB < lowerKC and upperBB > upperKC

    mid1 = (ta.highest(high, kcLen) + ta.lowest(low, kcLen)) / 2
    mid2 = (mid1 + ta.sma(close, kcLen)) / 2
    val  = ta.linreg(_src - mid2, kcLen, 0)

    [sqzOn, sqzOff, val]

//==================================================
// HTF & LTF
//==================================================
[l_on, l_off, l_val] = f_sqzmom(close)
[h_on, h_off, h_val] = request.security(syminfo.tickerid, htfTF, f_sqzmom(close))

//==================================================
// 趋势 & 风控
//==================================================
ema200 = ta.ema(close, emaLen)
atr    = ta.atr(atrLen)

strength = math.abs(l_val) / atr
dynRR = math.min(maxRR, baseRR + strength)

//==================================================
// 连续亏损熔断
//==================================================
var int lossStreak = 0
if strategy.closedtrades > 0
    lastPL = strategy.closedtrades.profit(strategy.closedtrades - 1)
    lossStreak := lastPL < 0 ? lossStreak + 1 : 0

canTrade = lossStreak < maxLossStreak

//==================================================
// 入场条件（黄金窗口）
//==================================================
longCond = sessionOK and canTrade and close > ema200 and h_off and l_off and l_val > 0 and l_val > l_val[1]
shortCond = sessionOK and canTrade and close < ema200 and h_off and l_off and l_val < 0 and l_val < l_val[1]

//==================================================
// 交易执行（双 TP + 统一止损）
//==================================================
if longCond
    strategy.entry("LONG", strategy.long)
    strategy.exit("TP1_L", "LONG", limit = close + atr * dynRR)
    strategy.exit("SL_L",  "LONG", stop  = close - atr)

if shortCond
    strategy.entry("SHORT", strategy.short)
    strategy.exit("TP1_S", "SHORT", limit = close - atr * dynRR)
    strategy.exit("SL_S",  "SHORT", stop  = close + atr)

//==================================================
// 可视化
//==================================================
plot(l_val,
     style=plot.style_histogram,
     color = l_val > 0 ? (l_val > l_val[1] ? color.lime : color.green)
                       : (l_val < l_val[1] ? color.red : color.maroon),
     linewidth=4)

plot(0, color = l_on ? color.black : l_off ? color.gray : color.blue)
