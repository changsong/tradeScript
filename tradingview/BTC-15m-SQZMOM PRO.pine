//@version=6
strategy(
     "BTC SQZMOM PRO v3.0 + Paper Trading + Panel",
     overlay=true,
     initial_capital=100000,
     pyramiding=0,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=100,
     commission_type=strategy.commission.percent,
     commission_value=0.08,
     calc_on_every_tick=true,
     process_orders_on_close=false)

//==================================================
// ğŸ”§ å‚æ•°
//==================================================
bbLen   = input.int(20, "BB Length")
bbMult  = input.float(2.0, "BB Mult")
kcLen   = input.int(20, "KC Length")
kcMult  = input.float(1.5, "KC Mult")
useTR   = input.bool(true, "Use TrueRange")
htfTF   = input.timeframe("60", "HTF")
emaLen  = input.int(200, "EMA Trend")
atrLen  = input.int(14, "ATR")
baseRR  = input.float(1.8, "Base RR")
maxRR   = input.float(3.0, "Max RR")
maxLossStreak = input.int(3, "Max Losing Streak")

//==================================================
// â° BTC æ—¶æ®µè¿‡æ»¤ï¼ˆUTCï¼‰
//==================================================
h = hour(time)
asia  = h >= 0  and h <= 8
us    = h >= 13 and h <= 20
sessionOK = asia or us

//==================================================
// ğŸ“ SQZMOM å‡½æ•°
//==================================================
f_sqzmom(_src) =>
    basis = ta.sma(_src, bbLen)
    dev   = bbMult * ta.stdev(_src, bbLen)
    upperBB = basis + dev
    lowerBB = basis - dev

    ma = ta.sma(_src, kcLen)
    rng = useTR ? ta.tr(true) : high - low
    rangema = ta.sma(rng, kcLen)
    upperKC = ma + rangema * kcMult
    lowerKC = ma - rangema * kcMult

    sqzOn  = (lowerBB > lowerKC) and (upperBB < upperKC)
    sqzOff = (lowerBB < lowerKC) and (upperBB > upperKC)

    mid = (ta.highest(high, kcLen) + ta.lowest(low, kcLen)) / 2
    mid2 = (mid + ta.sma(close, kcLen)) / 2
    val = ta.linreg(_src - mid2, kcLen, 0)

    [sqzOn, sqzOff, val]

//==================================================
// ğŸ”¹ LTF & HTF SQZMOM
//==================================================
[l_sqzOn, l_sqzOff, l_val] = f_sqzmom(close)
[h_sqzOn, h_sqzOff, h_val] = request.security(syminfo.tickerid, htfTF, f_sqzmom(close))

//==================================================
// ğŸ“ˆ è¶‹åŠ¿ & é£æ§
//==================================================
ema200 = ta.ema(close, emaLen)
atr    = ta.atr(atrLen)
strength = math.abs(l_val) / atr
dynRR = math.min(maxRR, baseRR + strength)

//==================================================
// ğŸš« è¿ç»­äºæŸç†”æ–­
//==================================================
var int lossStreak = 0
if strategy.closedtrades > 0
    lastPL = strategy.closedtrades.profit(strategy.closedtrades - 1)
    lossStreak := lastPL < 0 ? lossStreak + 1 : 0
canTrade = lossStreak < maxLossStreak

//==================================================
// âœ… å…¥åœºæ¡ä»¶ï¼ˆé»„é‡‘çª—å£ï¼‰
//==================================================
longCond =
    //  sessionOK and
    //  canTrade and
     close > ema200 
    //  and
    //  h_sqzOff and
    //  l_sqzOff and
    //  l_val > 0 and
    //  l_val > l_val[1]

shortCond =
     sessionOK and
     canTrade and
     close < ema200 and
     h_sqzOff and
     l_sqzOff and
     l_val < 0 and
     l_val < l_val[1]

//==================================================
// ğŸ¯ åˆ†æ‰¹æ­¢ç›ˆæ‰§è¡Œ
//==================================================
if longCond
    strategy.entry("LONG", strategy.long)
    strategy.exit("TP1_L", "LONG", limit = close + atr * dynRR, qty_percent = 50)
    strategy.exit("TP2_L", "LONG", stop  = close - atr)

if shortCond
    strategy.entry("SHORT", strategy.short)
    strategy.exit("TP1_S", "SHORT", limit = close - atr * dynRR, qty_percent = 50)
    strategy.exit("TP2_S", "SHORT", stop  = close + atr)

//==================================================
// ğŸ’¡ Paper Trading çŠ¶æ€ç›‘æ§ï¼ˆè¯Šæ–­ entryï¼‰
//==================================================
var bool paperEntryTriggered = false
if barstate.isrealtime and strategy.position_size == 0
    strategy.entry("diag_entry", strategy.long)
    paperEntryTriggered := true

hasPosition = strategy.position_size != 0
hasTrades   = strategy.closedtrades > 0

//==================================================
// ğŸ“Š å›¾è¡¨è§’è½æ˜¾ç¤ºçŠ¶æ€é¢æ¿
//==================================================
string statusText = ""
color  statusColor = color.gray
if not barstate.isrealtime
    statusText  := "ğŸ”´ æœªæ¥ç®¡ï¼ˆéå®æ—¶ï¼‰"
    statusColor := color.red
else if hasPosition or hasTrades
    statusText  := "ğŸŸ¢ å·²æ¥ç®¡ï¼ˆBTC SQZMOM PROï¼‰"
    statusColor := color.green
else if paperEntryTriggered
    statusText  := "ğŸŸ¡ ç­‰å¾…æˆäº¤"
    statusColor := color.orange
else
    statusText  := "ğŸ”´ æœªæ¥ç®¡"
    statusColor := color.red

var table panel = table.new(position.top_right, 1, 1, border_width = 1)
if barstate.islast
    table.cell(panel, 0, 0, statusText, bgcolor = statusColor, text_color = color.white, text_size = size.small)

//==================================================
// âš¡ æç¤º
//==================================================
// Webhook / Alert è§¦å‘æ–¹æ³•ï¼š
// 1. æ‰“å¼€ TradingView Alert
// 2. ç±»å‹é€‰æ‹© â€œOrder fills or any order in the strategyâ€
// 3. å¡«å†™ Webhook URL
// 4. ä¸‹å•ã€æ­¢ç›ˆã€è¯Šæ–­ entry éƒ½ä¼šè§¦å‘ Alerts
